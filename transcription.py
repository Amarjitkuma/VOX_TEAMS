#!/usr/bin/env python
# coding: utf-8

import logging
import sys
import requests
import time
import swagger_client
import os
import json

logging.basicConfig(stream=sys.stdout, level=logging.DEBUG,
                    format="%(asctime)s %(message)s", datefmt="%m/%d/%Y %I:%M:%S %p %Z")

# Your subscription key and region for the speech service
SUBSCRIPTION_KEY = ''
SERVICE_REGION = ''

NAME = "Simple transcription"
DESCRIPTION = "Simple transcription description"

LOCALE = "hi-in"
RECORDINGS_CONTAINER_URI = ""

MODEL_REFERENCE = None  # guid of a custom model

def parse_time_string(time_str):
    """
    Parse the time string formatted as PT#M#.#S to seconds as a float.
    Example: 'PT1M10.54S' -> 70.54
    """
    time_str = time_str[2:]  # Remove the 'PT' prefix
    minutes = 0
    seconds = 0
    
    if 'M' in time_str:
        parts = time_str.split('M')
        minutes = float(parts[0])
        if 'S' in parts[1]:
            seconds = float(parts[1].rstrip('S'))
    elif 'S' in time_str:
        seconds = float(time_str.rstrip('S'))
    
    total_seconds = minutes * 60 + seconds
    return total_seconds

def transcribe_from_container(uri, properties):
    """
    Transcribe all files in the container located at `uri` using the settings specified in `properties`
    using the base model for the specified locale.
    """
    transcription_definition = swagger_client.Transcription(
        display_name=NAME,
        description=DESCRIPTION,
        locale=LOCALE,
        content_container_url=uri,
        properties=properties
    )

    return transcription_definition

def _paginate(api, paginated_object):
    """
    The autogenerated client does not support pagination. This function returns a generator over
    all items of the array that the paginated object `paginated_object` is part of.
    """
    yield from paginated_object.values
    typename = type(paginated_object).__name__
    auth_settings = ["api_key"]
    while paginated_object.next_link:
        link = paginated_object.next_link[len(api.api_client.configuration.host):]
        paginated_object, status, headers = api.api_client.call_api(link, "GET",
            response_type=typename, auth_settings=auth_settings)

        if status == 200:
            yield from paginated_object.values
        else:
            raise Exception(f"could not receive paginated data: status {status}")

def delete_all_transcriptions(api):
    """
    Delete all transcriptions associated with your speech resource.
    """
    logging.info("Deleting all existing completed transcriptions.")

    # get all transcriptions for the subscription
    transcriptions = list(_paginate(api, api.get_transcriptions()))

    # Delete all pre-existing completed transcriptions.
    # If transcriptions are still running or not started, they will not be deleted.
    for transcription in transcriptions:
        transcription_id = transcription._self.split('/')[-1]
        logging.debug(f"Deleting transcription with id {transcription_id}")
        try:
            api.delete_transcription(transcription_id)
        except swagger_client.rest.ApiException as exc:
            logging.error(f"Could not delete transcription {transcription_id}: {exc}")

def transcribe():
    logging.info("Starting transcription client...")

    # configure API key authorization: subscription_key
    configuration = swagger_client.Configuration()
    configuration.api_key["Ocp-Apim-Subscription-Key"] = SUBSCRIPTION_KEY
    configuration.host = f"https://{SERVICE_REGION}.api.cognitive.microsoft.com/speechtotext/v3.1"

    # create the client object and authenticate
    client = swagger_client.ApiClient(configuration)

    # create an instance of the transcription api class
    api = swagger_client.CustomSpeechTranscriptionsApi(api_client=client)

    # Specify transcription properties
    properties = swagger_client.TranscriptionProperties()
    properties.diarization_enabled = True
    properties.diarization = swagger_client.DiarizationProperties(
        swagger_client.DiarizationSpeakersProperties(min_count=1, max_count=2))

    # Transcribe all files from a container
    transcription_definition = transcribe_from_container(RECORDINGS_CONTAINER_URI, properties)

    created_transcription, status, headers = api.transcriptions_create_with_http_info(transcription=transcription_definition)

    transcription_id = headers["location"].split("/")[-1]

    logging.info(f"Created new transcription with id '{transcription_id}' in region {SERVICE_REGION}")
    logging.info("Checking status.")

    completed = False

    while not completed:
        time.sleep(5)
        transcription = api.transcriptions_get(transcription_id)
        logging.info(f"Transcriptions status: {transcription.status}")

        if transcription.status in ("Failed", "Succeeded"):
            completed = True

        if transcription.status == "Succeeded":
            if properties.destination_container_url is not None:
                logging.info("Transcription succeeded. Results are located in your Azure Blob Storage.")
                break

            pag_files = api.transcriptions_list_files(transcription_id)
            for file_data in _paginate(api, pag_files):
                if file_data.kind != "Transcription":
                    continue

                audiofilename = file_data.name
                results_url = file_data.links.content_url
                results = requests.get(results_url)

                results_json = results.json()
                transcripts = []
                for phrase in results_json.get('recognizedPhrases', []):
                    speaker = phrase.get('speaker', 'Unknown')
                    offset = parse_time_string(phrase.get('offset', ''))
                    duration = parse_time_string(phrase.get('duration', ''))
                    text = phrase['nBest'][0].get('display', '')
                    confidence = phrase['nBest'][0].get('confidence', '')

                    transcript = {
                        "speaker": speaker,
                        "sentence": text,
                        "start_time": offset,
                        "end_time": duration + offset,
                        "confidence": confidence  
                    }
                    transcripts.append(transcript)

                output_filename = f"transcription.json"
                with open(output_filename, 'w', encoding='utf-8') as json_file:
                    json.dump(transcripts, json_file, ensure_ascii=False, indent=4)
                logging.info(f"Transcription saved to {output_filename}") 
        
        elif transcription.status == "Failed":
            logging.info(f"Transcription failed: {transcription.properties.error.message}")

if __name__ == "__main__":
    transcribe()
